# -*- coding: utf-8 -*-
"""Logistic .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14wZ2ON-o8cYj9OxUuTLM2RcdPQNUc2KQ

In this file, we work with four datasets that you need to upload to your session:


*   Duration_Purchase.csv
*   law_firm.csv
*   Mobile_Game.csv
*   Purchase_modalities

# Model Predictions - Regression
"""

import pandas as pd

df = pd.read_csv('Duration_Purchase.csv')
df

import statsmodels.formula.api as smf

model = smf.ols('spend ~ time_spent', data=df).fit()
print(model.summary())

# Creating a new dataset that we want to use for predictrion

new_df = pd.DataFrame({'time_spent': [5, 10, 15]})
new_df

# Get predictions using .predict() function
predicted_spend = model.predict(new_df)
print(predicted_spend)

"""# Law Firm Case"""

import pandas as pd
df = pd.read_csv('law_firm.csv')
df

# Running a regression model
import statsmodels.formula.api as smf
model = smf.ols('sale ~ pageviews', data=df).fit()
print(model.summary())

# Running a logistic regression (logit) model. Instead of smf.ols(), we use smf.logit()
import statsmodels.formula.api as smf
model = smf.logit('sale ~ pageviews', data=df).fit()
print(model.summary())

# Logistic Regression predictions
df['preds'] = model.predict(df)

df

"""# Mobile Game Case"""

import pandas as pd
df = pd.read_csv('Mobile_Game.csv')

df

# Ruuning a logistic regression
import statsmodels.formula.api as smf

model = smf.logit('converted ~ recency + frequency + monetary + discord_joined + cross_server_participation', data=df).fit()
print(model.summary())

"""**Question:** How would you interpret the above numbers?"""

df['preds'] = model.predict(df)

df

"""## Economic Calculations and Targeting"""

# Average response rate in the data
print(df['converted'].mean())

# Breakeven point calculations
cost_per_offer = 0.9
profit_per_buyer = 6.5

bep = cost_per_offer / profit_per_buyer
print(bep)

# We target customers if their predicted probability of response is higher than the break-even point
df['mailto'] = (df['preds'] > bep).astype(int)

df

# Proportion of people targeted
target_rate = df['mailto'].mean()

print(target_rate)

# Scale to full customer base
total_customers = 1000000
targeted_customers = target_rate * total_customers
print(targeted_customers)

# Actual response rate among the customers who we plan to target
targeted_response_rate = df[df['mailto'] == 1]['converted'].mean()

print(targeted_response_rate)

expected_buyers_logit = targeted_response_rate * targeted_customers

print(expected_buyers_logit)

profit_logit = profit_per_buyer * expected_buyers_logit - targeted_customers * cost_per_offer

print(profit_logit)

"""## What If We Use RFM?"""

# Defining quitiles of R, F, and M as we covered before in Session 5 Code file

df['rec_quin'] = pd.qcut(df['recency'].rank(method = 'first'), q=5, labels=False) + 1
df['freq_quin'] = 6 - (pd.qcut(df['frequency'].rank(method='first'), q=5, labels=False) + 1)
df['mon_quin'] = 6 - (pd.qcut(df['monetary'].rank(method='first'), q=5, labels=False) + 1)

df['rfmindex'] = 100 * df['rec_quin'] + 10 * df['freq_quin'] + df['mon_quin']

df['buyprob'] = df.groupby('rfmindex')['converted'].transform('mean')

df['mailto_RFM'] = (df['buyprob'] > bep).astype(int)

df

"""As we can see, RFM and logit tell us to target a differnt set of customers."""

# Proportion of people targeted under RFM
target_rate_RFM = df['mailto_RFM'].mean()

print(target_rate_RFM)

"""So here RFM tells us to target more people, instead of 53.4%, we now target 43.8% of customers. Is this justified or are we over-targeting?"""

# Scale to full customer base under RFM
targeted_customers_RFM = target_rate_RFM * total_customers
print(targeted_customers_RFM)

# Actual response rate among the customers who we plan to target under RFM
targeted_response_rate_RFM = df[df['mailto_RFM'] == 1]['converted'].mean()

print(targeted_response_rate_RFM)

expected_buyers_RFM = targeted_response_rate_RFM * targeted_customers_RFM

print(expected_buyers_RFM)

profit_RFM = profit_per_buyer * expected_buyers_RFM - targeted_customers_RFM * cost_per_offer

print(profit_RFM)

"""**Question:** What do you notice when you compare the results between the RFM and Logit models?

# Moving Beyond Binary
"""

df = pd.read_csv('Purchase_modalities.csv')

df

import statsmodels.formula.api as smf

model = smf.mnlogit('outcome ~ recency + sessions_30d + past_spend + email_opened + viewed_addon', data=df).fit()
print(model.summary())

"""If we have more than two classes in our outcome variable, we can opt for a model that is an extension of logit, which is called multinomial logit.

Running such a model in python is as easy as ruuning a logit. The only difference in estimation is that instead of using `smf.logit()`, we use `smf.mnlogit()`.

When it comes to predicting the model, we still use `.predict()` function. However, since in the case of a multi-classes, we have more than two classes, the prediction result will not be just one column that shows the probability of outcome to be 1. Instead, we will get multiple prediction columns, each predicting the probability of each class. For example, in our case, we have three classes of outcome: 0,1,2 and so we will get three probability columns corresponding to those outcomes.
"""

import statsmodels.formula.api as smf
model = smf.mnlogit('outcome ~ recency + sessions_30d + past_spend + email_opened + viewed_addon', data=df).fit()
# Getting predictions
probs = model.predict(df)

probs
